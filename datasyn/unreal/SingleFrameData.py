import trimesh
from trimesh.scene.transforms import SceneGraph
import trimesh.scene as triscene
import numpy as np
import re
from typing import Union
import pandas as pd

import igpy.common.util_trimesh as ut_trimesh
from igpy.common.calibration import CameraModel, intrinsic_matrix_by_fovx
import igpy.common.shortfunc as sf
from igpy.datasyn.ExrImage import ExrImage, CryptomatteIDMap, CryptomatteLayer

EPS_SMALL_FLOAT = 1e-8
class SceneObject:
    def __init__(self) -> None:
        # self.m_user_class_name : str = None  # user-defined class name
        # self.m_user_class_code : int = None  # user-defined code for this class
        self.m_instance_name : str = None   # display name in ue, unique for each scene object
        self.m_instance_code : int = None   # object id in exr
        
        self.m_asset_path : str = None  # the asset path of this object, if exists
        self.m_ue_class : str = None # name of the UE class 
        self.m_ue_object_name : str = None  # the internal object name in ue, generated by editor
        # self.m_ue_root_component : dict[str, str] = None    # root component information
        # self.m_ue_mesh_components : dict[str, dict] = None  # static mesh components
        
        self.m_meshlist : list[ut_trimesh.SceneMesh] = None # a list of meshes representing this object
        
        # we record redundant information (names) here because 
        # the corresponding scene objects may not have been loaded or set
        self.m_child_names : set[str] = None # names of child scene objects
        self.m_child_name2sobj : dict[str, SceneObject] = None # children objects
        self.m_parent_name : str = None  # name of the parent 
        self.m_parent_sobj : SceneObject = None # parent object
        self.m_transmat : np.ndarray = None # 4x4 right-multiply transformation matrix wrt world
        
        # linear pixel indices covered by this instance
        self.m_pixel_indices : np.ndarray = None
        self.m_image_size_hw: tuple = None  # image size in (height, width), of the image where this object is rendered
        
        # additional data associated with this object
        self.m_additional_data : dict[str, object] = {}
    
    @property
    def instance_name(self) -> str:
        ''' the unique name of this object, suitable for hash map
        '''
        return self.m_instance_name
    
    @property
    def instance_code(self) -> int:
        ''' the unique ID code of this object, suitable for hash map
        '''
        return self.m_instance_code
    
    @property
    def pixel_indices(self) -> np.ndarray:
        ''' 1d pixel indices occupied by this object
        '''
        return self.m_pixel_indices
    
    @property
    def image_size_hw(self)->tuple:
        return self.m_image_size_hw
    
    @property
    def has_parent(self) -> bool:
        if self.m_parent_name:
            return True
        else:
            return False
        
    @property
    def has_chilren(self) -> bool:
        if self.m_child_names:
            return True
        else:
            return False
        
    def get_bbox2_visible(self, include_child : bool = True) -> np.ndarray:
        ''' get the image space bounding box that encloses the visible part of the object.
        
        return
        ----------
        xywh : np.ndarray
            bounding box in (x,y,w,h) format
        '''
        assert self.m_image_size_hw is not None
        pix_indices = self.get_pixel_indices(include_child=include_child)
        if pix_indices is None or len(pix_indices) == 0:
            return None
        
        yy, xx = np.unravel_index(pix_indices, self.m_image_size_hw)
        minc = np.array([xx.min(), yy.min()])
        maxc = np.array([xx.max(), yy.max()])
        h, w = maxc - minc
        box_xywh = np.array([minc[0], minc[1], w, h], dtype=float)
        return box_xywh
    
    def get_bbox2_unoccluded(self, cam : CameraModel, include_child : bool = True) -> np.ndarray:
        ''' get unoccluded bounding box in image space.
        
        parameters
        ---------------
        cam
            the camera that sees this object
            
        return
        -----------
        xywh : np.ndarray
            2d bounding box in (x,y,w,h) format. If the object is partially or fully behind this camera,
            return None.
        '''
        # compute bounding box of itself, without considering children
        min_corner = []
        max_corner = []
        if self.m_meshlist:
            for meshobj in self.m_meshlist:
                # get points
                v = meshobj.get_transformed_vertices()
                
                # points in camera coordinate, check visibility
                v_cam = sf.transform_points(v, cam.extrinsic_4x4)
                has_point_behind = np.any(v_cam[:,-1] <= EPS_SMALL_FLOAT)
                if has_point_behind:
                    continue
                
                # project points to image space
                imgpts = cam.project_points(v)
                minc = imgpts.min(axis=0)
                maxc = imgpts.max(axis=0)
                min_corner.append(minc)
                max_corner.append(maxc)
                
        if include_child and self.m_child_name2sobj:
            for child_name, child_obj in self.m_child_name2sobj.items():
                child_bbox = child_obj.get_bbox2_unoccluded(cam)
                x,y,w,h = child_bbox
                min_corner.append(np.array([x,y]))
                max_corner.append(np.array([x+w, y+h]))
        
        # compute final min and max
        if not min_corner or not max_corner:
            return None
        else:
            minc = np.row_stack(min_corner).min(axis=0)
            maxc = np.row_stack(max_corner).max(axis=0)
            x,y = minc
            w,h = maxc - minc
            return np.array([x,y,w,h], dtype=float)
    
    def get_pixel_indices(self, include_child : bool = True) -> np.ndarray:
        ''' get all pixel indices including children
        '''
        pixlist = []
        if self.m_pixel_indices is not None:
            pixlist.append(self.m_pixel_indices)
            
        if include_child and self.m_child_name2sobj:
            for child_name, obj in self.m_child_name2sobj.items():
                pix = obj.get_pixel_indices()
                if pix is not None:
                    pixlist.append(pix)
        
        if pixlist:
            return np.concatenate(pixlist)
        else:
            return None
        
    def get_meshes(self, include_child : bool = True) -> list[ut_trimesh.SceneMesh]:
        ''' get all meshes including those in children
        
        return
        -----------
        meshlist : list[SceneMesh]
            a list of meshes belonging to this scene object
        '''
        output = []
        
        # self meshes
        if self.m_meshlist:
            output.extend(self.m_meshlist)
            
        # child meshes
        if include_child and self.m_child_name2sobj:
            for name, obj in self.m_child_name2sobj.items():
                child_meshes = obj.get_meshes(include_child=include_child)
            if child_meshes:
                output.extend(child_meshes)
        return output
    
    def get_merged_mesh(self, geometry_only : bool = True) -> trimesh.Trimesh:
        ''' find all submeshes (including those in children) and merge them. Texture will be discarded.
        
        parameters
        --------------
        geometry_only
            if True, the merged mesh only contains vertices and faces, discarding other information
        
        return
        -----------
        output_mesh
            a single mesh without texture
        '''
        from trimesh import visual
        submeshlist = self.get_meshes()
        
        if not submeshlist:
            return None
        
        mlist : list[trimesh.Trimesh] = []
        for x in submeshlist:
            if geometry_only:
                m = x.get_transformed_simple_mesh()
            else:
                m = x.get_transformed_mesh()
            mlist.append(m)
            
        output : trimesh.Trimesh = ut_trimesh.merge_trimesh_list(mlist)
        return output
        
    @property
    def asset_name(self) -> str:
        ''' asset name, the last segment of asset path
        '''
        if self.m_asset_path is None:
            return None
        else:
            return self.m_asset_path.split('/')[-1]
        
    @property
    def asset_path(self) -> str:
        ''' full path of the asset
        '''
        return self.m_asset_path
        

class SingleFrameData:
    ''' the most essential and detailed data for a single frame,
    which can be used to generate other labels
    '''
    COLOR_CHANNEL_DEFAULT_PREFIX = ['PathTracer', None]
    COLOR_CHANNEL_DEFAULT_POSTFIX = ['R','G','B','A']
    IDCODE_BEGIN = 1
    
    def __init__(self) -> None:
        self.m_exr_image : ExrImage = None # current exr image
        self.m_cryptomatte_max_rank = 0 # [0,1,2], the 
        
        # map instance name to scene mesh
        self.m_name2mesh : dict[str, ut_trimesh.SceneMesh] = {}
        self.m_scene_graph : SceneGraph = None # the trimesh SceneGraph, from gltf file
        
        # label the objects
        self.m_name2sobj : dict[str, SceneObject] = {}
        
        # scene structure info
        self.m_scene_structure : dict[str, Union[str,dict]] = None
        
        # color channel        
        self.m_chn_rgba : list[str] = None  # rgba channel names
        self.m_chn_rgba_postfix : list[str] = list(self.COLOR_CHANNEL_DEFAULT_POSTFIX) # rgba post fixes
        
        # self.m_name2class: dict[str, SemanticClass] = {}
        self.m_idcode_background : int = CryptomatteIDMap.IDCODE_BACKGROUND # background id, representing empty space in label map
        
        # mapping class name to object name pattern
        # entry is (class_name, [object_name_pattern, regex_method])
        # self.m_class2object_name_pattern : dict[str, tuple[str, str]] = None
        
        # camera in opencv convention
        self.m_camera : CameraModel = None
        
    @property
    def scene_objects_by_name(self) -> dict[str, SceneObject]:
        ''' scene objects indexed by instance names
        '''
        return self.m_name2sobj
    
    @property
    def scene_objects_by_instance_code(self) -> dict[int, SceneObject]:
        ''' scene objects indexed by instance code. 
        The construction of this dictionary takes time, use with care.
        '''
        if self.m_name2sobj is None:
            return None
        
        out = {}
        for name, obj in self.m_name2sobj.items():
            out[obj.instance_code] = obj
        return out
    
    @property
    def meshes(self) -> dict[str, ut_trimesh.SceneMesh]:
        ''' meshes indexed by their instance names. 
        Note that they are different from SceneObject's instance name
        '''
        return self.m_name2mesh
    
    @property
    def camera(self) -> CameraModel:
        ''' the camera (in opencv convention) with which this frame is rendered
        '''
        return self.m_camera
    
    @property
    def image_with_label(self) -> ExrImage:
        ''' the exr image containing all pixel-level information
        '''
        return self.m_exr_image
        
    def set_scene_structure(self, scene_struct : dict, scene_graph : SceneGraph):
        self.m_scene_structure = scene_struct
        self.m_scene_graph = scene_graph
        
    def set_exr_cryptomatte_max_rank(self, max_rank : int):
        self.m_cryptomatte_max_rank = max_rank
        
    def set_scene_meshes(self, meshlist : list[ut_trimesh.SceneMesh]):
        ''' Set all the static meshes in the scene, which are then used to compute bounding boxes.
        '''
        self.m_name2mesh = {}
        for m in meshlist:
            self.m_name2mesh[m.m_instance_name] = m
        
    def set_exr_image(self, img : ExrImage):
        assert isinstance(img ,ExrImage)
        self.m_exr_image = img
    
    def set_camera(self, cam : CameraModel):
        ''' set camera in opencv convention
        '''
        self.m_camera = cam
        
    def parse_scene(self):
        ''' parse the objects and labels. If meshes exist, also relate them to scene objects.
        '''
        
        # create scene objects
        name2obj : dict[str, SceneObject] = None
        if self.m_scene_structure:  # if we have scene structure, object names follows scene structure
            name2obj = create_objects_from_scene_structure(self.m_scene_structure)
            self.m_name2sobj = name2obj
        
        # parse label from exr image, and assign instance id code
        # the exr instance id code is consistent across frames
        if self.m_exr_image:
            self.m_exr_image.parse_cryptomatte(max_rank=self.m_cryptomatte_max_rank)
            exr_name2code = self.m_exr_image.crypto_name2code   # actor_name vs. idcode
            
            # no scene structure? use exr image to initilaize scene objects
            if name2obj is None:
                name2obj = {}
                for name, code in exr_name2code.items():
                    sc = SceneObject()
                    sc.m_instance_name = name
                    sc.m_instance_code = code
                    name2obj[name] = sc
                self.m_name2sobj = name2obj
            else:
                # have predefined scene objects
                # assign instance code to objects
                for name, code in exr_name2code.items():
                    obj : SceneObject = name2obj.get(name)
                    if not obj:
                        continue
                    obj.m_instance_code = code
            
            # extract pixel indices and assign them to objects
            import scipy.ndimage as ndimg
            from igpy.common.shortfunc import get_components_from_labelmap
            
            idmap_by_rank = self.m_exr_image.crypto_idmaps
            all_labels = list(exr_name2code.values())
            label2pix_final : dict[int, np.ndarray] = {}
            for idxrank, idmap in enumerate(idmap_by_rank):
                lbmap = idmap.label_map
                label2pix_thisrank = get_components_from_labelmap(lbmap, all_labels)
                
                # concatenate the pix indices to existing ones
                for lb, idxpix in label2pix_thisrank.items():
                    idxpix_prev = label2pix_final.get(lb)
                    if idxpix_prev is None:
                        label2pix_final[lb] = idxpix
                    else:
                        label2pix_final[lb] = np.concatenate([idxpix_prev, idxpix])
                        
            for name, obj in name2obj.items():
                idcode = obj.instance_code
                idxpix = label2pix_final.get(idcode)
                obj.m_pixel_indices = idxpix
                obj.m_image_size_hw = np.array(self.m_exr_image.image_size_hw)
                        
        # assign mesh to scene objects
        if self.m_name2mesh and self.m_scene_structure:
            assign_meshes_to_scene_objects(self.m_scene_structure,
                                           list(self.m_name2mesh.values()),
                                           name2obj)
        
    def get_color_image(self, dtype=np.uint8, gamma : float = None):
        ''' get RGBA image from exr file
        '''
        if not self.m_chn_rgba:
            chn_names = self._find_rgba_channel(self.m_exr_image)
            self.m_chn_rgba = chn_names
            
        if self.m_chn_rgba:
            output = self.m_exr_image.get_color_image(
                r_chn=self.m_chn_rgba[0],
                g_chn=self.m_chn_rgba[1],
                b_chn=self.m_chn_rgba[2],
                a_chn=self.m_chn_rgba[3],
                dtype = dtype,
                gamma=gamma
            )
        else:
            output = None
            
        return output
    
    def _find_rgba_channel(self, img : ExrImage) -> list[str]:
        ''' find default RGBA channel names
        '''
        
        output = []
        for prefix in self.COLOR_CHANNEL_DEFAULT_PREFIX:
            if prefix is None:  # no prefix, the postfix is the channel name
                expect_chn_names = self.m_chn_rgba_postfix
            else:
                expect_chn_names = ['{}.{}'.format(prefix, p) for p in self.m_chn_rgba_postfix]
                
            # find channels
            found_channel = 0
            for chn_name in img.channel_names:
                if chn_name in expect_chn_names:
                    found_channel += 1
                    
            if found_channel == len(expect_chn_names):
                output = expect_chn_names
                break
            
        return output
    
    def get_instance_label_map(self, return_all_ranks : bool = False) -> Union[np.ndarray, list[np.ndarray]]:
        ''' get instance label map of this frame
        
        parameters
        -------------
        return_all_ranks
            if True, return a list of label maps, each corresponding to a rank of the exr image
            
        return
        -----------
        lbmap_or_list : np.ndarray | list
            a label map of the highest rank in exr if return_all_ranks==False.
            Otherwise, return a list of label maps, sorted by rank, 
            output[0] is of the highest rank
        '''
        if not self.m_exr_image:
            return None
        
        output = [x.label_map for x in self.m_exr_image.crypto_idmaps]
        if return_all_ranks:
            return output
        else:
            return output[0]
class SceneStructureInfo:
    ''' keys and values relevant to the scene structure json file
    '''
    class Keys:
        RootActors = "actors"
        Components = 'components'
        UEClassName = 'class_name'
        UERootCompName = 'root_component'
        ObjectName = 'object_name'
        GLTFNode = 'gltf_node'
        AssetPath = 'asset_path'
        ParentActor = 'parent_actor'
    
    class UEClassName:
        StaticMeshComponent = 'StaticMeshComponent'
        
######
def create_objects_from_scene_structure(scene_struct : dict) -> dict[str, SceneObject]:
    ''' create scene objects from scene struct, and establish the parent-child relationship.
    '''
    Keys = SceneStructureInfo.Keys
    output : dict[str, SceneObject] = {}
    
    ss_actors : dict = scene_struct[Keys.RootActors]
    actor_info : dict = None
    for disp_name, actor_info in ss_actors.items():
        # this actor does not have component, skip
        if Keys.Components not in actor_info:
            continue
        
        # update a scene object if it exists, otherwise create it
        obj : SceneObject = SceneObject()
        output[disp_name] = obj
            
        # set up basic info
        obj.m_ue_class = actor_info.get(Keys.UEClassName)
        obj.m_parent_name = actor_info.get(Keys.ParentActor)
        obj.m_instance_name = disp_name
        obj.m_asset_path = actor_info.get(Keys.AssetPath)
        obj.m_ue_object_name = actor_info.get(Keys.ObjectName)
        
        # root_comp = actor_info.get(Keys.UERootCompName)
        # if root_comp: 
        #     obj.m_ue_root_component = actor_info[Keys.Components][root_comp]
                
    # establish parent-child relationship
    for name, obj in output.items():
        if obj.m_parent_name in output:
            parent_obj : SceneObject = output[obj.m_parent_name]
            obj.m_parent_sobj = parent_obj
            
            if parent_obj.m_child_names is None:
                parent_obj.m_child_names = set()
            parent_obj.m_child_names.add(name)
            
            if parent_obj.m_child_name2sobj is None:
                parent_obj.m_child_name2sobj = {}
            parent_obj.m_child_name2sobj[name] = obj
            
    return output
    
def assign_meshes_to_scene_objects(scene_struct : dict, 
                          meshlist : list[ut_trimesh.SceneMesh],
                          name2sobj : dict[str, SceneObject]):
    ''' parse scene structure from ue, and then create or update a set of scene objects following
    that structure
    
    parameters
    -----------
    scene_struct
        the scene structure json object output by ue
    meshlist
        a list of meshes loaded from gltf file
    name2sobj
        scene objects whose meshes will be updated
    '''
    Keys = SceneStructureInfo.Keys
    
    # construct trie for prefix search
    import marisa_trie
    name2mesh = {x.m_instance_name:x for x in meshlist}
    mesh_name_prefix_search = marisa_trie.Trie(list(name2mesh.keys()))
    
    ss_actors : dict = scene_struct[Keys.RootActors]
    actor_info : dict = None
    for disp_name, actor_info in ss_actors.items():
        
        # no object for this actor
        if disp_name not in name2sobj:
            continue
        
        # no component, skip update
        if Keys.Components not in actor_info:
            continue
        
        # update a scene object if it exists, otherwise create it
        obj : SceneObject = name2sobj[disp_name]
            
        # find mesh components and update scene object
        obj.m_meshlist = []
        for comp_name, comp_info in actor_info[Keys.Components].items():
            # look for static mesh component
            if Keys.UEClassName not in comp_info:
                continue
            
            if comp_info[Keys.UEClassName] != SceneStructureInfo.UEClassName.StaticMeshComponent:
                continue
            
            # found a static mesh component, look for gltf mesh using prefix tree
            gltf_node_prefx = comp_info[Keys.GLTFNode]
            submesh_names : list[str] = mesh_name_prefix_search.keys(gltf_node_prefx)
            if submesh_names:
                # add relevant meshes to scene object
                obj.m_meshlist.extend([name2mesh[x] for x in submesh_names])
            
###########################

class SceneGeometryParser:
    ''' parse the scene into SceneObject hierarchy
    '''
    def __init__(self) -> None:
        self.m_scene_struct : dict[str, dict] = None    # ue scene structure
        self.m_scene_content : triscene.Scene = None  # scene loaded by trimesh 
        
        # object selection
        self.m_include_name_pattern : re.Pattern = None    # only include scene objects with this named pattern
        self.m_exclude_name_pattern : re.Pattern = None    # exclude scene objects with this pattern
        self.m_apply_object_selection_to_root_only : bool = True    # only apply these patterns to root objects
        
        # parse results
        self.m_name2sobj : dict[str, SceneObject] = None
        self.m_name2mesh : dict[str, ut_trimesh.SceneMesh] = None
        
    def init(self, scene_structure : dict[str, dict], scene_content : triscene.Scene):
        self.m_scene_struct = scene_structure
        self.m_scene_content = scene_content
        
    def set_include_name_pattern(self, ptn : str):
        if ptn is None:
            self.m_include_name_pattern = None
        else:
            self.m_include_name_pattern = re.compile(ptn)
            
    def set_exclude_name_pattern(self, ptn : str):
        if ptn is None:
            self.m_exclude_name_pattern = None
        else:
            self.m_exclude_name_pattern = re.compile(ptn)
            
    def parse(self):
        ''' parse the scene into object hierarchy
        '''
        self._parse_scene_objects()
        self._parse_scene_geometry()
    
    def _check_if_accept_ue_actor(self, actor_name : str, actor_info : dict[str, dict]) -> bool:
        ''' given ue actor info from scene structure, determine if it will be included in output
        '''
        
        Keys = SceneStructureInfo.Keys
        
        # no component, no object creation
        complist = actor_info.get(Keys.Components)
        if not complist:
            return False
        
        # have scene content? then check if any of the components is in scene content.
        # if no component is in scene content, skip it
        if self.m_scene_content is not None:
            in_content = False
            scene = self.m_scene_content
            for comp_name, comp_info in actor_info.get(Keys.Components).items():
                gltf_node_name : str = comp_info.get(Keys.GLTFNode)
                if gltf_node_name is not None and gltf_node_name in scene.graph:
                    in_content = True
                    break
            if not in_content:
                return False
        
        # filter by names
        if self.m_include_name_pattern is not None or self.m_exclude_name_pattern is not None:
            # selection apply to root object but the target is not root, just accept it
            root_only_selection = self.m_apply_object_selection_to_root_only
            if root_only_selection and Keys.ParentActor in actor_info:
                return True
            
            # include pattern
            include_ptn = self.m_include_name_pattern
            if include_ptn is not None:
                m = include_ptn.match(actor_name)
                if not m:
                    return False
                
            # exclude pattern
            exclude_ptn = self.m_exclude_name_pattern
            if exclude_ptn is not None:
                m = exclude_ptn.match(actor_name)
                if m:
                    return False
                
        return True
    
    def _parse_scene_objects(self) -> dict[str, SceneObject]:
        assert self.m_scene_struct is not None
        
        Keys = SceneStructureInfo.Keys
        actor_struct = self.m_scene_struct.get(Keys.RootActors)
        output : dict[str, SceneObject] = {}
        
        actor_info : dict = None
        for disp_name, actor_info in actor_struct.items():
            # this actor does not have component, skip
            # if Keys.Components not in actor_info:
            #     continue
            
            accept_this_actor = self._check_if_accept_ue_actor(disp_name, actor_info)
            if not accept_this_actor:
                continue
            
            # update a scene object if it exists, otherwise create it
            obj : SceneObject = SceneObject()
            output[disp_name] = obj
                
            # set up basic info
            obj.m_ue_class = actor_info.get(Keys.UEClassName)
            obj.m_parent_name = actor_info.get(Keys.ParentActor)
            obj.m_instance_name = disp_name
            obj.m_asset_path = actor_info.get(Keys.AssetPath)
            obj.m_ue_object_name = actor_info.get(Keys.ObjectName)
            
            # root_comp = actor_info.get(Keys.UERootCompName)
            # if root_comp: 
            #     obj.m_ue_root_component = actor_info[Keys.Components][root_comp]
                    
        # establish parent-child relationship
        for name, obj in output.items():
            if obj.m_parent_name in output:
                parent_obj : SceneObject = output[obj.m_parent_name]
                obj.m_parent_sobj = parent_obj
                
                if parent_obj.m_child_names is None:
                    parent_obj.m_child_names = set()
                parent_obj.m_child_names.add(name)
                
                if parent_obj.m_child_name2sobj is None:
                    parent_obj.m_child_name2sobj = {}
                parent_obj.m_child_name2sobj[name] = obj
                
        self.m_name2sobj = output
        return output
        # end of _parse_scene_objects()
        
    def _parse_scene_geometry(self) -> dict[str, ut_trimesh.SceneMesh]:
        ''' assign mesh to scene objects
        '''
        assert self.m_scene_content is not None
        assert self.m_name2sobj is not None, 'parse scene object first'
        
        import networkx as nx
        
        # get all meshes
        scene : triscene.Scene = self.m_scene_content
        g : nx.DiGraph = scene.graph.to_networkx()
        name2node = scene.graph.to_flattened()
        
        all_meshes = ut_trimesh.flatten_trimesh_scene(scene)
        name2mesh = {}
        for m in all_meshes:
            name2mesh[m.m_instance_name] = m
        
        # for each scene object, find the mesh and associate them
        Keys = SceneStructureInfo.Keys
        sobj : SceneObject = None
        actor_struct = self.m_scene_struct.get(Keys.RootActors)
        comp_info : dict[str, str] = None
        for name, sobj in self.m_name2sobj.items():
            actor_info : dict[str, Union[str, dict]] = actor_struct[sobj.instance_name]
            
            # assign its own node transformation
            root_comp_name = actor_info.get(Keys.UERootCompName)
            if root_comp_name is not None:
                root_comp : dict = actor_info[Keys.Components][root_comp_name]
                gltf_node_name : str = root_comp.get(Keys.GLTFNode)
                if gltf_node_name is not None and gltf_node_name in scene.graph:
                    left_tmat, _ = scene.graph.get(frame_to=gltf_node_name, frame_from=scene.graph.base_frame)
                    sobj.m_transmat = np.ascontiguousarray(left_tmat.T)
            
            # collect all submeshes
            meshlist = []
            for comp_name, comp_info in actor_info[Keys.Components].items():
                # look for static mesh component
                comp_type : str = comp_info.get(Keys.UEClassName)
                if comp_type != SceneStructureInfo.UEClassName.StaticMeshComponent:
                    continue
                
                # found, get gltf node
                gltf_node_name = comp_info.get(Keys.GLTFNode)
                if gltf_node_name is None:
                    continue
                
                # gltf node not in scene graph? pass
                if gltf_node_name not in scene.graph:
                    continue
                
                # get meshes
                root_mesh = name2mesh.get(gltf_node_name)
                if root_mesh:
                    meshlist.append(root_mesh)
                    
                for gltf_child_name in nx.descendants(g, gltf_node_name):
                    child_mesh = name2mesh.get(gltf_child_name)
                    if child_mesh:
                        meshlist.append(child_mesh)
                        
                if meshlist:
                    sobj.m_meshlist = meshlist
                else:
                    sobj.m_meshlist = None
                
        self.m_name2mesh = name2mesh
        return name2mesh
        # end of _parse_scene_geometry()
                
                
                
                
        
        
        
        